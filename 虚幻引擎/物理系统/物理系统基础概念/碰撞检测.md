在游戏引擎的物理系统中，碰撞检测是检测游戏物体之间是否发生接触或穿透的关键步骤。碰撞检测通常是游戏物理模拟的重要组成部分，它确保物体在运动时不会相互穿透，并且能提供准确的物理反馈，如碰撞反弹、摩擦、以及碰撞后施加的力。碰撞检测可以分为广义相交检测和精确碰撞检测，并且有不同的算法和方法来提高效率和准确性。

### 碰撞检测的主要类型

#### 1. 广义相交检测（Broad-phase Collision Detection）
广义相交检测的目的是减少要进行精确碰撞检测的物体对数，通过快速算法确定哪些物体有可能发生碰撞，然后再对这些物体进行详细的检测。这是碰撞检测的第一步，通常适用于大量物体的场景。

- AABB（Axis-Aligned Bounding Box，轴对齐边界框）：
    - 每个物体用一个与坐标轴对齐的矩形或立方体包围盒表示。
    - 快速检测两个AABB是否相交，可以通过比较其边界的位置来完成。
    - 优点：计算简单，效率高。
    - 缺点：无法处理物体的旋转。

- 空间划分（Spatial Partitioning）：
    - 网格分割（Grid Partitioning）：将场景划分为多个网格块，每个物体只检测其所在网格和相邻网格中的物体。
    - 八叉树（Octree）和四叉树（Quadtree）：根据场景复杂度递归地划分空间，树节点代表某一区域，子节点表示更小的区域。
    - 优点：减少了需要进行检测的物体对数。
    - 缺点：对于高速运动的物体，可能会穿越多个网格，增加检测复杂性。

- 扫掠和量测（Sweep and Prune）：
    - 物体在一个维度上进行排序，只检测在该维度上可能重叠的物体。
    - 优点：适合动态场景，更新代价较低。
    - 缺点：对高速运动物体的处理不佳。

#### 2. 精确碰撞检测（Narrow-phase Collision Detection）
精确碰撞检测是针对广义检测中识别出的潜在碰撞物体对，进一步判断它们是否真正发生碰撞。不同的物体形状需要不同的检测算法。

- 球体碰撞检测（Sphere Collision Detection）：
    - 每个物体用一个球体表示，两个球体的碰撞检测通过比较它们的中心点距离和半径之和。
    - 优点：计算简单，尤其适合旋转物体。
    - 缺点：球形表示不够精确，可能导致误判。

- 盒子碰撞检测（Box Collision Detection）：
    - 使用轴对齐边界框（AABB）或方向包围盒（OBB）来表示物体，检测两个盒子是否发生碰撞。
    - AABB 的检测通过简单的边界比较，OBB 需要考虑物体的旋转，涉及矩阵变换。
    - 优点：对规则形状的物体很有效。
    - 缺点：对于复杂形状，精确性较差。

- 凸多边形检测（Convex Hull Collision Detection）：
    - 使用凸多边形来表示物体的边界，检测两个凸多边形是否相交。
    - GJK算法（Gilbert-Johnson-Keerthi Algorithm）：常用的凸多边形碰撞检测算法，计算两个凸形状的最小距离，如果距离为0，则物体发生碰撞。
    - 优点：适用于复杂形状的碰撞检测，精度高。
    - 缺点：计算量较大，性能相对较低。

- 网格碰撞检测（Mesh Collision Detection）：
    - 对于复杂的三维模型，使用精确的网格进行碰撞检测，每个网格由多个三角形面组成。
    - 面-面检测：检测两个物体的表面三角形是否相交。
    - 优点：能够处理非常复杂的几何形状。
    - 缺点：计算量巨大，不适合实时应用，通常只在特殊情况下使用，如静态场景或关键交互物体。

- 点-形状检测（Point vs Shape Detection）：
    - 用于检测一个点（如射线、光标）是否与某个形状发生碰撞。
    - 常用于射线投射（Ray Casting）和选择物体等交互操作。

#### 3. 连续碰撞检测（Continuous Collision Detection, CCD）
当物体运动速度较快时，离散碰撞检测可能会错过某些碰撞，导致物体穿透。这时候就需要连续碰撞检测，它能检测物体在一帧内的整个移动路径上是否发生了碰撞。

- 时间插值法（Time of Impact, TOI）：
    - 检测物体在每一帧中的运动轨迹，确定碰撞发生的确切时间点并提前处理。
    - 适合高速移动的物体如子弹、投射物等。

- 运动包围盒（Swept Bounding Box）：
    - 使用物体的运动轨迹计算其在一帧内的包围盒，并检测该包围盒是否与其他物体相交。
    - 能够处理线性运动中的碰撞。

#### 4. 复合碰撞检测（Compound Collision Detection）
一些复杂的物体可以由多个简单的碰撞体组合而成。复合碰撞检测通过对每个子碰撞体进行检测，再综合结果判断整体物体是否发生碰撞。

- 例子：车辆的碰撞体可以由多个盒子和球体组合而成，用来模拟车身、轮胎等部分的碰撞。

#### 5. 碰撞过滤（Collision Filtering）
为了提高性能，物理引擎通常支持碰撞过滤，允许开发者定义哪些物体应该进行碰撞检测，哪些不应该进行。

- 碰撞层（Collision Layers）：物体可以被分配到不同的层，只有指定层之间的物体才会进行碰撞检测。
- 碰撞掩码（Collision Masks）：通过掩码可以更细粒度地控制哪些物体能够进行碰撞检测。

### 常见碰撞检测算法

#### 1. GJK算法（Gilbert-Johnson-Keerthi Algorithm）
- 用于凸多边形之间的碰撞检测。通过迭代方式找到两个凸多边形的最近点，判断它们是否相交。
- 适用于任意凸形物体，尤其是在3D物理引擎中非常常见。

#### 2. SAT算法（Separating Axis Theorem, 分离轴定理）
- 用于检测两个凸多边形或多面体是否碰撞。算法原理是，如果在某个轴上，两个物体的投影不重叠，那么它们就没有发生碰撞。
- 适用于凸形物体，能快速排除不可能发生碰撞的物体对。

#### 3. BVH算法（Bounding Volume Hierarchies, 边界体层次结构）
- 使用层次化的包围体（如AABB或球体）来组织场景中的物体，通过递归遍历结构，可以快速减少需要检测的物体对。
- 常用于复杂场景中的碰撞检测优化。

#### 4. 枪射线检测（Ray Casting）
- 检测一条射线与物体是否相交，常用于选择、射击检测、光线追踪等场景。
- 通过计算射线与物体的交点，可以获得碰撞点和法线，用于后续的物理或渲染计算。

### 碰撞检测的优化技巧

- 物体层级管理：通过分层次检测减少不必要的碰撞检测，如背景物体与动态物体可以在不同层中。
- 启用碰撞睡眠机制：当物体在场景中长时间不发生运动时，物理引擎可以将其标记为“睡眠”，跳过碰撞检测以提高性能。
- 减少复杂碰撞形状：对复杂形状的物体，可以用更简单的形状来代表进行碰撞检测，如使用胶囊体或盒子来替代复杂的网格模型。
