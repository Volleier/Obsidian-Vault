#技术栈/优化/线程优化

# 概念总结
是线程池优化方案的概念总结，不涉及具体语言实现：
## 合理设置线程池大小
- CPU 密集型任务：线程数接近 CPU 核心数，避免过多线程竞争 CPU 资源。
- I/O 密集型任务：线程数可适当增加，以充分利用任务等待 I/O 的时间。

## 选择合适的线程池类型
- 固定大小线程池：适用于任务量稳定的场景。
- 动态调整线程池：适用于任务量波动较大的场景。
- 定时任务线程池：适用于需要定时或周期性执行的任务。
- 单线程池：适用于需要顺序执行任务的场景。
- 分治任务线程池：适用于可分解的递归或并行任务。

## 任务队列优化
- 无界队列：适合任务量可控的场景，但可能导致内存溢出。
- 有界队列：限制队列大小，避免资源耗尽，但可能触发拒绝策略。
- 优先级队列：根据任务优先级调度执行。

## 拒绝策略优化
- 直接丢弃：丢弃新任务，适用于对任务丢失不敏感的场景。
- 丢弃最旧任务：丢弃队列中最旧的任务，腾出空间给新任务。
- 调用者运行：由提交任务的线程直接执行任务，降低提交速度。
- 抛出异常：拒绝新任务并抛出异常，适用于需要快速失败处理的场景。

## 线程池监控与动态调整
- 监控线程池状态：包括活跃线程数、任务队列大小、完成任务数等。
- 动态调整参数：根据监控数据动态调整线程池大小、队列容量等参数。

## 线程复用与资源管理
- 减少线程创建开销：通过线程复用避免频繁创建和销毁线程。
- 合理设置线程超时：对空闲线程设置超时回收，避免资源浪费。

## 任务拆分与并行化
- 任务分治：将大任务拆分为多个小任务，并行执行。
- 异步任务链：将任务拆分为多个阶段，通过回调或事件驱动机制串联执行。

## 避免线程池滥用
- 避免过度使用线程池：过多的线程池会增加系统复杂度，导致资源竞争。
- 区分任务类型：为不同类型的任务（如 CPU 密集型、I/O 密集型）分配独立的线程池。

## 异常处理与任务重试
- 统一异常处理：捕获任务执行中的异常，避免线程因异常退出。
- 任务重试机制：对失败任务进行重试，提高任务执行的可靠性。

## 资源隔离与优先级控制
- 资源隔离：为关键任务分配独立的线程池，避免资源竞争。
- 优先级控制：通过优先级队列或任务调度策略，确保高优先级任务优先执行。

# 具体实践
使用 Netty 或 Spring WebFlux 实现异步非阻塞 I/O，提升并发处理能力
## Netty
Netty 是一个异步事件驱动的网络框架，适用于高性能、高并发的网络应用。
[Netty官网](https://netty.io/)

### 核心概念
- EventLoop: 负责处理 I/O 事件，每个 EventLoop 绑定一个线程，处理多个 Channel 的事件。
- Channel: 代表一个网络连接，支持异步操作。
- ChannelHandler: 处理 I/O 事件，如数据读取、写入等。
- ChannelPipeline: 包含多个 ChannelHandler，按顺序处理事件。

### 线程池优化
- EventLoopGroup: 管理多个 EventLoop，通常分为 bossGroup（接受连接）和 workerGroup（处理连接）。
- 自定义线程池: 对于耗时操作（如数据库访问），可以使用自定义线程池，避免阻塞 EventLoop。

### 示例代码
```java
EventLoopGroup bossGroup = new NioEventLoopGroup(1);
EventLoopGroup workerGroup = new NioEventLoopGroup();

try {
    ServerBootstrap b = new ServerBootstrap();
    b.group(bossGroup, workerGroup)
     .channel(NioServerSocketChannel.class)
     .childHandler(new ChannelInitializer<SocketChannel>() {
         @Override
         public void initChannel(SocketChannel ch) {
             ch.pipeline().addLast(new MyChannelHandler());
         }
     });

    ChannelFuture f = b.bind(8080).sync();
    f.channel().closeFuture().sync();
} finally {
    bossGroup.shutdownGracefully();
    workerGroup.shutdownGracefully();
}
```

## Spring WebFlux
Spring WebFlux 是 Spring 5 引入的响应式编程框架，支持异步非阻塞 I/O

### 核心概念
- eactive Streams: 提供异步流处理的标准接口（Publisher、Subscriber、Subscription、Processor）。
- Reactor: Spring WebFlux 的默认实现，提供 Mono（0-1 个元素）和 Flux（0-N 个元素）两种发布者。

### 线程池优化
- Schedulers: Reactor 提供多种调度器（如 `Schedulers.parallel()`、`Schedulers.elastic()`），用于控制异步操作的执行线程。
- 自定义线程池: 通过 `Schedulers.fromExecutorService()` 使用自定义线程池。

### 示例代码
```java
@RestController
public class MyController {

    @GetMapping("/flux")
    public Flux<String> getFlux() {
        return Flux.interval(Duration.ofMillis(100))
                   .map(i -> "Value: " + i)
                   .take(10);
    }

    @GetMapping("/mono")
    public Mono<String> getMono() {
        return Mono.just("Hello, WebFlux!");
    }
}
```