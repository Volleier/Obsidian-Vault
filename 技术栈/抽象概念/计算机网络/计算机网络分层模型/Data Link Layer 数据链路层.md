数据链路层是OSI参考模型的第二层，位于物理层和网络层之间，负责在直接相连的节点（如同一局域网内的设备）之间提供可靠的数据传输。

# 数据链路层核心功能
## 基本功能
数据链路层主要功能包括：将数据打包成帧、用MAC地址寻址、检测传输错误、控制数据流量。常见协议有以太网和Wi-Fi，典型设备是交换机。

常见概念：
- 帧（Frame）的封装与解封装：将网络层的数据包封装成帧，添加头部和尾部信息。
- 物理寻址：通过MAC地址标识设备。
- 差错控制：检测或纠正传输中的错误（如CRC校验）。
- 流量控制：协调发送方和接收方的速率（如滑动窗口协议）。
- 介质访问控制（MAC）：解决共享信道中的冲突问题（如以太网的CSMA/CD）。

## 组帧（成帧）
数据链路层的组帧（成帧）主要有字符计数法、字符填充法、比特填充法、物理层编码违例法

这是对比：

| 方式       | 标志类型   | 填充/转义机制      | 适用场景         | 主要缺点        |
| -------- | ------ | ------------ | ------------ | ----------- |
| 字符计数法    | 长度字段   | 无            | 早期协议（如DDCMP） | 计数错误导致灾难性后果 |
| 字符填充法    | 控制字符   | 插入ESC转义字符    | 文本传输（如PPP）   | 不适用于二进制数据   |
| 比特填充法    | 比特模式   | 插入"0"避免连续"1" | 二进制数据（如HDLC） | 硬件实现复杂      |
| 物理层编码违例法 | 非法电平信号 | 无            | 特定物理层（如曼彻斯特） | 依赖物理层编码     |

---
### 字符计数法（Character Count）

#### 原理
在帧的起始位置使用一个固定长度的字段（通常是1-2字节）来记录整个帧的字节数。
接收方根据该计数字段确定帧的结束位置。

#### 示例
```text
[长度:5][数据:HELLO][长度:8][数据:NETWORK]...
```
第一帧：长度=5，数据="HELLO"
第二帧：长度=8，数据="NETWORK"

#### 特点
- 优点：实现简单，无需填充或转义字符。
- 缺点：
    - 如果计数字段出错（如传输错误），后续所有帧都会错位（**灾难性错误传播**）。
    - 帧长度受限（取决于计数字段的位数）

### 字符填充法（Character Stuffing）

#### 原理
使用特定的控制字符作为帧的起始（STX，ASCII 0x02）和结束（ETX，ASCII 0x03）标志。
若数据中出现控制字符，则插入转义字符（ESC，ASCII 0x1B）进行填充。
接收方删除转义字符恢复原始数据。
#### **示例：*
- 帧格式：`STX [数据] ETX`
- 数据中包含`ETX`时：  
    原始数据：`A ETX B` → 填充后：`STX A ESC ETX B ETX`

#### 特点
- 优点：适合文本传输（如ASCII协议）。
- 缺点：
    - 依赖特定字符集（如ASCII），不适用于二进制数据。
    - 转义字符本身也需要处理（若数据中出现ESC，需双重转义）。

### 比特填充法（Bit Stuffing）

#### 原理：
使用特定的比特模式作为帧边界（如HDLC协议使用`01111110`作为帧首尾标志）。
发送方在数据中遇到连续5个"1"时，自动插入一个"0"（避免与标志混淆）。
接收方删除插入的"0"恢复原始数据。

#### 示例
- 标志：`01111110`
- 原始数据：`01111111`（连续6个"1"）→ 填充后：`011111011`（在第5个"1"后插入"0"）
    
#### 特点
- 优点
    - 适用于二进制数据，效率高于字符填充法。
    - 广泛用于现代协议（如HDLC、以太网）。
- 缺点：硬件实现稍复杂（需比特级操作）。

### 物理层编码违例法（Physical Layer Violation）

#### 原理
利用物理层编码规则中未使用的信号状态（如曼彻斯特编码中的高-高或低-低电平）作为帧界。
无需在帧中添加额外的标志位。

#### 特点
- 优点：节省带宽（无需显式添加帧标志）。
- 缺点：
    - 依赖特定物理层编码方式（如曼彻斯特编码）。
    - 现代高速网络较少使用。

# 差错控制
## 检错编码
### 奇偶校验码
奇偶校验法（Parity Check）是一种简单的错误检测方法，主要用于验证数据在传输或存储过程中是否出现错误。其核心思想是通过增加一个冗余位（奇偶校验位），使数据中“1”的个数满足奇偶性（奇数或偶数）的预设规则。
#### 基本原理
1. 奇校验（Odd Parity）：确保数据（包括校验位）中“1”的总数为奇数。
2. 偶校验（Even Parity）：确保数据（包括校验位）中“1”的总数为偶数。

#### 实现步骤
发送端：
- 计算原始数据中“1”的个数。
- 根据校验类型（奇/偶）添加校验位：
        - 若为偶校验且“1”的个数已为偶数，校验位为`0`；否则为`1`。
                - 若为奇校验且“1”的个数已为奇数，校验位为`0`；否则为`1`。
- 发送数据时附带校验位。
接收端：
    - 接收数据后，重新计算“1”的个数（包括校验位）。
    - 检查是否满足预设的奇偶性：
        - 若满足，认为数据正确。
        - 若不满足，判定数据存在错误。
            

### **示例**

假设传输数据 `1011`，采用偶校验：

- 原始数据中“1”的个数为3（奇数），故校验位为`1`，使总“1”数变为4（偶数）。
    
- 发送完整数据：`1011` + `1` → `10111`。
    
- 接收端检测到“1”的个数为4（偶数），则判断无错误。
    

### **优缺点**

- **优点**：
    
    - 简单高效，硬件实现成本低。
        
    - 适用于少量错误检测（如单比特错误）。
        
- **缺点**：
    
    - 只能检测奇数个比特错误（若两位同时出错，无法发现）。
        
    - 无法纠正错误，仅能提示错误存在。
        
    - 不适用于高噪声环境或高可靠性需求场景。

## 纠错编码


# 流量控制与可靠传输


# 介质访问控制（MAC）


# 局域网（LAN）技术


# 广域网（WAN）