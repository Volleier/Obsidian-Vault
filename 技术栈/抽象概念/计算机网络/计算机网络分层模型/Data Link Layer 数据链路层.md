数据链路层是OSI参考模型的第二层，位于物理层和网络层之间，负责在直接相连的节点（如同一局域网内的设备）之间提供可靠的数据传输。

# 数据链路层核心功能
## 基本功能
数据链路层主要功能包括：将数据打包成帧、用MAC地址寻址、检测传输错误、控制数据流量。常见协议有以太网和Wi-Fi，典型设备是交换机。

常见概念：
- 帧（Frame）的封装与解封装：将网络层的数据包封装成帧，添加头部和尾部信息。
- 物理寻址：通过MAC地址标识设备。
- 差错控制：检测或纠正传输中的错误（如CRC校验）。
- 流量控制：协调发送方和接收方的速率（如滑动窗口协议）。
- 介质访问控制（MAC）：解决共享信道中的冲突问题（如以太网的CSMA/CD）。

## 组帧（成帧）
数据链路层的组帧（成帧）主要有字符计数法、字符填充法、比特填充法、物理层编码违例法

这是对比：

| 方式       | 标志类型   | 填充/转义机制      | 适用场景         | 主要缺点        |
| -------- | ------ | ------------ | ------------ | ----------- |
| 字符计数法    | 长度字段   | 无            | 早期协议（如DDCMP） | 计数错误导致灾难性后果 |
| 字符填充法    | 控制字符   | 插入ESC转义字符    | 文本传输（如PPP）   | 不适用于二进制数据   |
| 比特填充法    | 比特模式   | 插入"0"避免连续"1" | 二进制数据（如HDLC） | 硬件实现复杂      |
| 物理层编码违例法 | 非法电平信号 | 无            | 特定物理层（如曼彻斯特） | 依赖物理层编码     |

---
### 字符计数法（Character Count）

#### 原理
在帧的起始位置使用一个固定长度的字段（通常是1-2字节）来记录整个帧的字节数。
接收方根据该计数字段确定帧的结束位置。

#### 示例
```text
[长度:5][数据:HELLO][长度:8][数据:NETWORK]...
```
第一帧：长度=5，数据="HELLO"
第二帧：长度=8，数据="NETWORK"

#### 特点
- 优点：实现简单，无需填充或转义字符。
- 缺点：
    - 如果计数字段出错（如传输错误），后续所有帧都会错位（**灾难性错误传播**）。
    - 帧长度受限（取决于计数字段的位数）

### 字符填充法（Character Stuffing）

#### 原理
使用特定的控制字符作为帧的起始（STX，ASCII 0x02）和结束（ETX，ASCII 0x03）标志。
若数据中出现控制字符，则插入转义字符（ESC，ASCII 0x1B）进行填充。
接收方删除转义字符恢复原始数据。
#### 示例
- 帧格式：`STX [数据] ETX`
- 数据中包含`ETX`时：  
    原始数据：`A ETX B` → 填充后：`STX A ESC ETX B ETX`

#### 特点
- 优点：适合文本传输（如ASCII协议）。
- 缺点：
    - 依赖特定字符集（如ASCII），不适用于二进制数据。
    - 转义字符本身也需要处理（若数据中出现ESC，需双重转义）。

### 比特填充法（Bit Stuffing）

#### 原理：
使用特定的比特模式作为帧边界（如HDLC协议使用`01111110`作为帧首尾标志）。
发送方在数据中遇到连续5个"1"时，自动插入一个"0"（避免与标志混淆）。
接收方删除插入的"0"恢复原始数据。

#### 示例
- 标志：`01111110`
- 原始数据：`01111111`（连续6个"1"）→ 填充后：`011111011`（在第5个"1"后插入"0"）
    
#### 特点
- 优点
    - 适用于二进制数据，效率高于字符填充法。
    - 广泛用于现代协议（如HDLC、以太网）。
- 缺点：硬件实现稍复杂（需比特级操作）。

### 物理层编码违例法（Physical Layer Violation）

#### 原理
利用物理层编码规则中未使用的信号状态（如曼彻斯特编码中的高-高或低-低电平）作为帧界。
无需在帧中添加额外的标志位。

#### 特点
- 优点：节省带宽（无需显式添加帧标志）。
- 缺点：
    - 依赖特定物理层编码方式（如曼彻斯特编码）。
    - 现代高速网络较少使用。

# 差错控制
| 方法   | 功能    | 复杂度 | 适用场景            |
| ---- | ----- | --- | --------------- |
| 奇偶校验 | 单比特检错 | 低   | 低速通信、内存校验       |
| CRC  | 多比特检错 | 中   | 网络协议、存储系统       |
| 海明码  | 检错+纠错 | 高   | 需要纠错的场景（如ECC内存） |
## 检错编码

### 奇偶校验码
奇偶校验法（Parity Check）是一种简单的错误检测方法，主要用于验证数据在传输或存储过程中是否出现错误。其核心思想是通过增加一个冗余位（奇偶校验位），使数据中“1”的个数满足奇偶性（奇数或偶数）的预设规则。
- 优点：
    - 简单高效，硬件实现成本低。
    - 适用于少量错误检测（如单比特错误）。
- 缺点：
    - 只能检测奇数个比特错误（若两位同时出错，无法发现）。
    - 无法纠正错误，仅能提示错误存在。
    - 不适用于高噪声环境或高可靠性需求场景。

#### 基本原理
1. 奇校验（Odd Parity）：确保数据（包括校验位）中“1”的总数为奇数。
2. 偶校验（Even Parity）：确保数据（包括校验位）中“1”的总数为偶数。

#### 实现步骤
发送端：
- 计算原始数据中“1”的个数。
- 根据校验类型（奇/偶）添加校验位：
	- 若为偶校验且“1”的个数已为偶数，校验位为`0`；否则为`1`。
	- 若为奇校验且“1”的个数已为奇数，校验位为`0`；否则为`1`。
- 发送数据时附带校验位。
接收端：
- 接收数据后，重新计算“1”的个数（包括校验位）。
- 检查是否满足预设的奇偶性：
	- 若满足，认为数据正确。
	- 若不满足，判定数据存在错误。

#### 示例
假设传输数据 `1011`，采用偶校验：
- 原始数据中“1”的个数为3（奇数），故校验位为`1`，使总“1”数变为4（偶数）。
- 发送完整数据：`1011` + `1` → `10111`。
- 接收端检测到“1”的个数为4（偶数），则判断无错误。

### 循环冗余校验码
循环冗余校验码（CRC） 是一种广泛使用的错误检测编码，通过多项式除法计算校验值，能够高效地检测数据传输或存储中的错误（如比特翻转、突发错误等）。其核心思想是将数据视为二进制多项式，通过模2除法生成冗余校验码。
- CRC通过多项式除法生成校验码，是高效可靠的检错方法。
- 适用于对错误敏感但无需纠错的场景（如网络传输）。
- 实际应用中需根据需求选择生成多项式（如CRC-16、CRC-32）。

优点：
- 高检错能力：可检测所有单比特错误、双比特错误、奇数位错误及突发错误（突发长度 ≤ CRC位数）。
- 高效：硬件实现简单（移位寄存器+异或门）。
- 广泛应用：网络通信（Ethernet、Wi-Fi）、存储系统（ZIP、RAID）、文件传输（FTP）等。
缺点：
- 仅能检错，无法纠错：需结合其他机制（如重传）修复错误。
- 无法对抗故意篡改：CRC非加密算法，不适用于安全校验。

基本原理：
1. 数据多项式：将待传输的二进制数据表示为多项式（如 `1011` → x3+x+1x3+x+1）。
2. 生成多项式：收发双方预先约定一个固定多项式（如CRC-8、CRC-16等），用于计算校验码。
3. 模2除法：数据多项式除以生成多项式，得到的余数即为CRC校验码。
4. 校验过程：接收方用相同方法计算CRC，若余数为0则数据正确，否则存在错误。

#### CRC计算步骤
发送端：生成CRC校验码
1. 数据扩展：在原始数据末尾补 nn 个0（nn 为生成多项式的最高次幂）。
    - 例如：数据 `1101`，生成多项式 x3+x+1x3+x+1（对应 `1011`），补3个0 → `1101000`。
2. 模2除法：用扩展后的数据除以生成多项式（按位异或运算）。
    - 除法过程忽略借位，每一步用生成多项式对齐当前最高有效位进行异或。
3. 获取余数：除法的余数即为CRC校验码（位数=生成多项式位数-1）。
4. 附加校验码：将余数替换到原始数据补0的位置，得到最终发送数据。

接收端：校验数据
1. 用接收到的数据（含CRC）除以相同的生成多项式。
2. 若余数为0，数据正确；否则存在错误。

#### 示例
##### 假设：
- 原始数据：`1101`
- 生成多项式：x3+x+1x3+x+1（二进制 `1011`）

##### 发送端计算CRC：
- 数据补3个0 → `1101000`。
- 模2除法：
```text
       1101000 (数据)
     ⊕ 1011    (生成多项式对齐最高位)
       -----
        011000
      ⊕ 1011
        -----
         1110
       ⊕ 1011
         -----
          1010
        ⊕ 1011
          -----
           001 (余数=CRC= `001`)
```
- 发送数据：原始数据 + CRC = `1101` + `001` → `1101001`。

##### 接收端验证：
用 `1101001` 除以 `1011`，余数为0则无误。
#### 常见生成多项式

| 标准     | 多项式（二进制）                            | 用途           |
| ------ | ----------------------------------- | ------------ |
| CRC-8  | `100000111`                         | 简单通信（如I2C总线） |
| CRC-16 | `11000000000000101`                 | Modbus、USB设备 |
| CRC-32 | `100000100110000010001110110110111` | ZIP、PNG、以太网  |

## 纠错编码
### 海明码
海明码是一种经典的错误检测与纠正编码（EDAC, Error Detection and Correction），由理查德·海明（Richard Hamming）于1950年提出。它通过在数据位中插入多个校验位，不仅能检测错误，还能精确定位并纠正单比特错误（或检测双比特错误），广泛应用于内存（如ECC RAM）、通信系统等领域。
- 海明码通过巧妙的校验位分布和奇偶校验关系，实现单比特错误的检测与纠正。
- 冗余度低（仅需 log⁡2(k)log2​(k) 位校验位），适合高可靠性场景。
- 是理解现代纠错编码（如Reed-Solomon、LDPC）的基础。

核心思想：
1. 校验位分布：将校验位插入到数据位的特定位置（位置号为2的幂次方，如1, 2, 4, 8…）。
2. 奇偶校验分组：每个校验位负责覆盖部分数据位，通过奇偶校验关系建立关联。
3. 错误定位：通过校验位的组合结果（称为综合征/Syndrome）直接定位错误位。

#### 编码步骤
##### 确定校验位数量
若原始数据位数为 kk，校验位数为 rr，需满足：$2r≥k+r+12r≥k+r+1$
例如：
- 对4位数据（如 `1011`），需3位校验位 $（2^3=8≥4+3+1）$。
- 对11位数据，需4位校验位$（2^4=16≥11+4+1）$。

##### 插入校验位
校验位的位置为$2^{i−1}$  （即第1, 2, 4, 8…位），数据位填充其余位置。  
**示例**：对4位数据 `D3 D2 D1 D0`（`1011`），插入校验位 `P2 P1 P0`后的7位编码：
```text
位置： 7 6 5 4 3 2 1  
数据：D3 D2 D1 P2 D0 P1 P0  
填充后：1 0 1 _ 1 _ _  
```

##### 计算校验位
每个校验位 PiPi​ 覆盖位置号二进制表示中第 ii 位为1的数据位：
- P0（位置1）：覆盖所有位置号末位为1的位（1, 3, 5, 7…）。
- P1（位置2）：覆盖所有位置号倒数第二位为1的位（2, 3, 6, 7…）。
- P2（位置4）：覆盖所有位置号倒数第三位为1的位（4, 5, 6, 7…）。

计算示例（偶校验）：
- P0 = D0 ⊕ D1 ⊕ D3 = 1 ⊕ 1 ⊕ 1 = 1
- P1 = D0 ⊕ D2 ⊕ D3 = 1 ⊕ 0 ⊕ 1 = 0
- P2 = D1 ⊕ D2 ⊕ D3 = 1 ⊕ 0 ⊕ 1 = 0  
    最终编码：`1 0 1 0 1 0 1`（位置7→1）。

#### 解码与纠错

##### 计算综合征（Syndrome）
接收方重新计算各校验位的奇偶性，将结果按 P2P1P0P2P1P0 顺序组合为二进制数，其值直接指示错误位置（若为0则无错误）。
- 单比特错误：可检测并纠正。
- 双比特错误：可检测但无法纠正（需扩展海明码）。
- 多比特错误：可能漏检。

示例：假设接收到的数据为 `1 0 1 0 1 1 1`（第2位出错）：
- P0_new = 1 ⊕ 1 ⊕ 1 ⊕ 1 = 0（原P0=1，不一致）
- P1_new = 1 ⊕ 0 ⊕ 1 ⊕ 1 = 1（原P1=0，不一致）
- P2_new = 1 ⊕ 0 ⊕ 1 = 0（原P2=0，一致）  
    综合征：S=P2P1P0=011S=P2P1P0=011（二进制3），表示第3位出错。

##### 纠正错误
翻转错误位（第3位）：`1 0 1 0 1 1 1` → `1 0 0 0 1 1 1`（恢复正确数据）。

#### （扩展）海明码的变种
- 扩展海明码（SEC-DED）：增加一个全局奇偶校验位，可检测双比特错误并纠正单比特错误（用于ECC内存）。
- 海明距离：编码理论中衡量纠错能力的基础概念（海明码的最小距离为3）。

# 流量控制与可靠传输
## 流量控制（Flow Control）
**目的**：防止发送方发送数据过快，导致接收方缓冲区溢出。  
**核心思想**：接收方通过反馈机制动态调整发送方的发送速率。

##### **实现方式**：

1. **停等协议（Stop-and-Wait）**：
    
    - 发送方每发送一个数据包，需等待接收方的确认（ACK）后再发送下一个。
        
    - **缺点**：信道利用率低（尤其在长延迟网络中）。
        
2. **滑动窗口协议（Sliding Window）**：
    
    - 允许发送方连续发送多个数据包（窗口大小内的数据），无需逐个等待ACK。
        
    - 接收方通过窗口通告（Window Advertisement）告知剩余缓冲区大小。

## 可靠传输（Reliable Transmission）

# 介质访问控制（MAC）


# 局域网（LAN）技术


# 广域网（WAN）