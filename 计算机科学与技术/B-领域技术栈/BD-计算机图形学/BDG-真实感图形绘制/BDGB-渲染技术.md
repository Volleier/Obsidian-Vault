# 介绍

| 特性        | Z-Buffer | 扫描线渲染      | 隐藏线渲染  | 光线追踪            |
| --------- | -------- | ---------- | ------ | --------------- |
| **主要用途**  | 实时3D渲染   | 早期图形系统     | 工程线框显示 | 高质量离线渲染         |
| **可见性判定** | 逐像素深度比较  | 扫描线深度排序    | 线可见性测试 | 光线求交            |
| **内存需求**  | 高（深度缓冲区） | 中（边表）      | 低      | 极高（加速结构）        |
| **计算复杂度** | O(n×p)   | O(n×log e) | O(l×s) | 指数级（递归深度）       |
| **图像质量**  | 中等，有走样   | 中等         | 仅轮廓线   | 极高，真实感          |
| **处理能力**  | 任意复杂表面   | 多边形表面      | 线框模型   | 任意几何和光学效果       |
| **实时性能**  | 优秀（硬件加速） | 差（软件实现）    | 中等     | 差（传统）→ 中等（现代硬件） |
| **实现难度**  | 简单       | 复杂         | 中等     | 非常复杂            |

# 渲染技术分类
## Z-Buffer（深度缓冲）算法

### 概述
深度缓冲（Depth Buffer），又称Z缓冲区（Z-buffer）或w缓冲区，是计算机图形学中用于处理三维图像深度坐标的技术，通常由硬件实现，也可通过软件处理。

该技术通过存储像素点的深度值确定物体遮挡关系，解决场景可见性问题。与需要几何体排序的画家算法（效率较低但支持透明元素渲染）不同，深度缓冲通过逐像素深度比较更新缓冲区，较小值的像素将覆盖原有颜色。深度缓冲算法需要帧缓冲存储像素值，z缓冲存储对应z值，初始化时深度值设为最大值 。深度缓冲分辨率直接影响场景质量：16位缓冲区可能导致远近物体显示异常，24位或32位缓冲区表现更优。w缓冲通过均匀分布精度改善远距离显示，但硬件支持度较低。现代技术采用低分辨率分层设计、反向Z投影优化存储结构，并通过SIMD指令加速处理。

该概念由艾德文·卡特姆等人提出，Wolfgang Straßer的博士论文也提及相同思想。发展过程中深度缓冲的压缩技术、清除机制逐步应用于图形硬件，光线追踪等渲染方法也开始结合其加速计算

### 核心原理
- 深度值存储：为每个像素存储距离观察者（相机）最近的深度值（Z值）
- 深度比较：处理多边形时，计算当前多边形在像素位置的深度值，与缓冲中存储的深度值比较
- 颜色更新：只有当当前深度值小于缓冲中存储的深度值时，才更新该像素的颜色和深度值

### 关键组件
| 组件    | 说明                     | 数据类型                      |
| ----- | ---------------------- | ------------------------- |
| 深度缓冲区 | 存储每个像素的深度值，通常使用浮点数数组   | float/depth buffer        |
| 颜色缓冲区 | 存储每个像素的颜色/强度值，即最终显示的图像 | color buffer/frame buffer |
| 模板缓冲区 | （可选）用于特殊效果，如阴影、反射等     | stencil buffer            |

### 算法流程
```pseudocode
初始化：
    深度缓冲区 ← 最大深度值（通常为1.0或远裁剪面距离）
    颜色缓冲区 ← 背景颜色

对于每个多边形表面：
    对于多边形覆盖的每个像素(x,y)：
        计算该像素处的深度值z_current
        如果 z_current < 深度缓冲区[x][y]：
            深度缓冲区[x][y] ← z_current
            颜色缓冲区[x][y] ← 多边形在该像素的颜色
```

### 深度值的计算
- **透视投影**：深度值需经过透视除法，非线性分布（近处精度高，远处精度低）
- **深度范围**：通常归一化到[0,1]或[近裁剪面, 远裁剪面]
- **深度冲突**：当两个表面非常接近时，可能出现深度比较的不确定性

### 特点与优缺点
**优点：**
- 算法简单，易于硬件实现
- 处理复杂度为O(n)，n为像素数量×多边形数量
- 不受场景复杂度影响，只与分辨率相关
- 处理任意几何形状，包括相互穿透的表面

**缺点：**
- 内存消耗大（深度缓冲区通常与颜色缓冲区等大）
- 过度绘制（多个多边形在同一像素计算，但只有最近的有效）
- 深度精度问题，尤其是远距离物体
- 无法直接处理透明物体

### 变种与改进
- **W-Buffer**：使用倒数深度，改善深度精度分布
- **分层Z-Buffer**：使用多分辨率深度图，提前剔除不可见区域
- **Early-Z测试**：在像素着色前进行深度测试，减少不必要的着色计算

## 扫描线渲染算法

### 概述
扫描线渲染是一种**基于对象空间与屏幕空间结合**的渲染方法，通过逐行（扫描线）处理屏幕空间，确定每个像素的可见表面。它是早期软件渲染器和一些专业CAD系统的核心算法。

### 核心概念
- **扫描线**：屏幕上的水平线，算法逐行从上到下处理
- **边**：多边形边界线段，连接两个顶点
- **扫描线连贯性**：相邻扫描线上的像素信息变化平缓，可增量计算

### 数据结构
#### 1. 边表（ET - Edge Table）
存储所有非水平边，按边的最大y坐标（上端点）分组：
```plaintext
边结构包含：
- y_max：边的上端点y坐标
- x_min：边在当前扫描线的最低x坐标（初始为下端点的x）
- 1/m：边的斜率倒数（dx/dy）
- 指向多边形的指针
```

#### 2. 活动边表（AEL - Active Edge List）
存储与当前扫描线相交的所有边，按x交点排序：
- 每处理一条扫描线，更新AEL中所有边的x坐标：x = x + 1/m
- 当边达到y_max时，从AEL中移除

### 算法流程
```pseudocode
初始化边表ET，按y_max分组

for 每条扫描线 y = y_min to y_max:
    1. 将ET中y_max = y的边加入AEL
    2. 对AEL按x交点排序
    3. 确定扫描线区间：在AEL中成对取边，形成[x_left, x_right]区间
    4. 确定每个区间内的可见多边形：
        - 计算每个多边形在扫描线上的深度
        - 选择深度最小的多边形（最近的多边形）
    5. 填充区间：使用可见多边形的颜色填充像素
    6. 更新AEL：所有边的x += 1/m
    7. 移除AEL中y_max = y的边
```

### 深度计算优化
- **增量深度计算**：利用平面方程 z = Ax + By + C，可增量更新：
  ```
  z_scanline_start = A*x_start + B*y + C
  z_next_pixel = z_current + A  (当B=0时)
  ```
- **边相关性**：相邻扫描线上同一多边形的深度变化连续

### 特点与优缺点
**优点：**
- 内存效率高（无需全屏深度缓冲区）
- 适合早期内存受限的系统
- 可处理大规模多边形场景
- 易于实现反走样（在扫描线级别）

**缺点：**
- 算法复杂度高，实现复杂
- 难以处理相互穿透的多边形
- 对动态场景更新效率低
- 现代硬件支持差

### 应用场景
- 早期计算机图形系统（1990年代前）
- 专业CAD/CAM软件（需要精确的2D投影）
- 矢量图形显示
- 某些特殊效果的软件渲染

## 隐藏线渲染算法

### 概述
隐藏线渲染专门处理**线框模型**的可见性，消除被表面遮挡的线条，仅显示物体从当前视角可见的轮廓线。常用于工程制图、建筑可视化和CAD系统。

### 核心问题
- **线可见性判定**：判断线段是被完全可见、部分可见还是完全隐藏
- **轮廓线识别**：识别物体的外轮廓和内部特征线
- **交线处理**：正确处理表面的交线可见性

### 常用方法

#### 1. 基于表面的隐藏线消除
- 将线框模型转换为表面模型
- 使用Z-Buffer或扫描线算法判断表面可见性
- 仅绘制可见表面边界上的线条

#### 2. 优先度算法（Painter's Algorithm变种）
- 按深度排序所有表面
- 从后往前处理表面
- 标记被遮挡的线段部分

#### 3. 浮动水平线算法
- 用于参数曲面和函数图形的隐藏线消除
- 维护上水平线和下水平线
- 确定函数图形的可见部分

### 算法流程（基于表面的方法）
```pseudocode
1. 表面可见性计算：
    使用Z-Buffer或扫描线算法确定每个像素的可见表面
    
2. 边可见性判断：
    对于每条边（线段）：
        a. 采样边上的多个点
        b. 检查每个采样点的可见性：
            - 计算采样点的深度
            - 与对应像素的深度缓冲区比较
        c. 根据采样结果确定边的可见状态：
            - 全可见：所有采样点可见
            - 全隐藏：所有采样点不可见
            - 部分可见：部分采样点可见
    
3. 可见边绘制：
    绘制全可见边
    对部分可见边进行裁剪，仅绘制可见部分
```

### 特殊处理
- **轮廓线增强**：加粗或高亮显示外轮廓线
- **隐藏线样式**：用虚线或浅色表示隐藏线（可选）
- **交线计算**：精确计算表面交线及其可见性
- **深度提示**：根据深度调整线条亮度或粗细

### 特点与优缺点
**优点：**
- 保持线框模型的简洁性
- 增强三维理解，避免视觉歧义
- 适合工程和技术绘图
- 数据量小，适合早期显示设备

**缺点：**
- 计算复杂，需要表面信息
- 处理曲线和曲面困难
- 实时性能差
- 无法表示表面材质和光照效果

### 现代应用
- CAD软件中的线框显示模式
- 建筑蓝图和技术图纸
- 3D建模软件的轮廓显示
- 教育演示中的几何可视化

## 光线追踪渲染

### 概述
光线追踪是一种**基于物理光学模拟**的全局光照算法，通过追踪光线在场景中的传播路径，计算每个像素的颜色值。能够生成照片级真实感的图像，但计算量巨大。

### 核心原理
- **逆向光线追踪**：从相机出发向场景发射光线，而非从光源出发
- **递归追踪**：跟踪光线的反射、折射等多次反弹
- **蒙特卡洛方法**：使用随机采样估计全局光照

### 基本算法
```pseudocode
function traceRay(ray, depth):
    if depth > MAX_DEPTH:
        return BACKGROUND_COLOR
    
    // 1. 寻找最近的交点
    hit_record = findClosestIntersection(ray)
    
    if no intersection:
        return BACKGROUND_COLOR
    
    // 2. 计算局部光照（直接光照）
    color = computeLocalIllumination(hit_record)
    
    // 3. 递归追踪反射光线
    if material is reflective:
        reflection_ray = computeReflectionRay(hit_record)
        color += traceRay(reflection_ray, depth+1) * reflectivity
    
    // 4. 递归追踪折射光线
    if material is transparent:
        refraction_ray = computeRefractionRay(hit_record)
        color += traceRay(refraction_ray, depth+1) * transparency
    
    // 5. 阴影测试
    for each light source:
        shadow_ray = ray from hit_point to light
        if shadow_ray hits an object:
            color *= shadow_factor
    
    return color
```

### 关键技术组件

#### 1. 光线表示
```
Ray: origin + t * direction
t ∈ [0, ∞) 或 [t_min, t_max]
```

#### 2. 光线-物体求交
- **球体**：二次方程求解
- **平面**：线性方程求解
- **三角形**：Möller-Trumbore算法
- **包围盒**：Slab方法
- **加速结构**：BVH、KD-Tree、BSP Tree

#### 3. 材质模型
- **漫反射**：Lambertian模型
- **镜面反射**：Phong/Blinn-Phong模型
- **折射**：Snell定律，Fresnel方程
- **各向异性**：微表面模型

#### 4. 光照计算
- **直接光照**：点光源、方向光、面光源
- **间接光照**：路径追踪、光子映射
- **环境光**：环境光遮蔽、IBL

### 加速技术
| 技术 | 原理 | 优点 |
|------|------|------|
| **包围体层次** | 将物体分组到层次包围盒中 | 自适应细分，适合复杂场景 |
| **KD-Tree** | 递归空间二分 | 高效，适合静态场景 |
| **BVH** | 基于对象的层次包围盒 | 动态场景支持好 |
| **空间划分** | 均匀网格划分 | 简单，适合均匀分布物体 |
| **光束追踪** | 同时追踪光束而非单光线 | 减少冗余计算 |

### 现代扩展
- **路径追踪**：无偏的蒙特卡洛全局光照
- **光子映射**：双向光线追踪
- **辐射度算法**：基于热辐射的全局光照
- **实时光线追踪**：硬件加速（RTX）、降噪技术

### 特点与优缺点
**优点：**
- 照片级真实感图像质量
- 自然处理阴影、反射、折射
- 精确的全局光照效果
- 理论上可模拟所有光学现象

**缺点：**
- 计算量极大，渲染时间长
- 内存消耗大（加速结构）
- 实现复杂，调试困难
- 噪声问题（蒙特卡洛方法）

### 应用领域
- 电影和动画制作（离线渲染）
- 建筑可视化
- 产品设计和广告
- 科学可视化
- 实时渲染的混合方法（光栅化+光线追踪）
