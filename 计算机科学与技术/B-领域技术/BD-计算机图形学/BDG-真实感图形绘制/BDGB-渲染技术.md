# 介绍
计算机图形学发展出了多种渲染算法，不同算法在不同领域都有重要作用

| 特性       | Z-Buffer | 扫描线渲染      | 隐藏线渲染  | 光线追踪            |
| -------- | -------- | ---------- | ------ | --------------- |
| 主要用途     | 实时3D渲染   | 早期图形系统     | 工程线框显示 | 高质量离线渲染         |
| 可见性判定    | 逐像素深度比较  | 扫描线深度排序    | 线可见性测试 | 光线求交            |
| 内存需求     | 高（深度缓冲区） | 中（边表）      | 低      | 极高（加速结构）        |
| 计算复杂度    | O(n×p)   | O(n×log e) | O(l×s) | 指数级（递归深度）       |
| 图像质量     | 中等，有走样   | 中等         | 仅轮廓线   | 极高，真实感          |
| 处理能力 | 任意复杂表面   | 多边形表面      | 线框模型   | 任意几何和光学效果       |
| 实时性能 | 优秀（硬件加速） | 差（软件实现）    | 中等     | 差（传统）→ 中等（现代硬件） |
| 实现难度 | 简单       | 复杂         | 中等     | 非常复杂            |

# 渲染技术分类
## 深度缓冲

### 概述
| 中文名  | 外文名          | 别名             |
| ---- | ------------ | -------------- |
| 深度缓冲 | Depth Buffer | Z-buffer（Z缓冲区） |

深度缓冲通过存储像素点的深度值确定物体遮挡关系，解决场景可见性问题。与需要几何体排序的画家算法（效率较低但支持透明元素渲染）不同，深度缓冲通过逐像素深度比较更新缓冲区，较小值的像素将覆盖原有颜色。深度缓冲算法需要帧缓冲存储像素值，z缓冲存储对应z值，初始化时深度值设为最大值 。深度缓冲分辨率直接影响场景质量：16位缓冲区可能导致远近物体显示异常，24位或32位缓冲区表现更优。w缓冲通过均匀分布精度改善远距离显示，但硬件支持度较低。现代技术采用低分辨率分层设计、反向Z投影优化存储结构，并通过SIMD指令加速处理。
![[Pasted image 20260104143724.png]]
深度缓冲概念由艾德文·卡特姆等人提出，Wolfgang Straßer的博士论文也提及相同思想。发展过程中深度缓冲的压缩技术、清除机制逐步应用于图形硬件，光线追踪等渲染方法也开始结合其加速计算

#### 核心原理
- 深度值存储：为每个像素存储距离观察者（相机）最近的深度值（Z值）
- 深度比较：处理多边形时，计算当前多边形在像素位置的深度值，与缓冲中存储的深度值比较
- 颜色更新：只有当当前深度值小于缓冲中存储的深度值时，才更新该像素的颜色和深度值

#### 关键组件
| 组件    | 说明                     | 数据类型                      |
| ----- | ---------------------- | ------------------------- |
| 深度缓冲区 | 存储每个像素的深度值，通常使用浮点数数组   | float/depth buffer        |
| 颜色缓冲区 | 存储每个像素的颜色/强度值，即最终显示的图像 | color buffer/frame buffer |
| 模板缓冲区 | （可选）用于特殊效果，如阴影、反射等     | stencil buffer            |

### 算法流程
```pseudocode
初始化：
    深度缓冲区 ← 最大深度值（通常为1.0或远裁剪面距离）
    颜色缓冲区 ← 背景颜色

对于每个多边形表面：
    对于多边形覆盖的每个像素(x,y)：
        计算该像素处的深度值z_current
        如果 z_current < 深度缓冲区[x][y]：
            深度缓冲区[x][y] ← z_current
            颜色缓冲区[x][y] ← 多边形在该像素的颜色
```
算法要点：
- 透视投影：深度值需经过透视除法，非线性分布（近处精度高，远处精度低）
- 深度范围：通常归一化到\[0,1\]或\[近裁剪面, 远裁剪面\]
- 深度冲突：当两个表面非常接近时，可能出现深度比较的不确定性

### 特点与优缺点
#### 优点
- 算法简单，易于硬件实现
- 处理复杂度为O(n)，n为像素数量×多边形数量
- 不受场景复杂度影响，只与分辨率相关
- 处理任意几何形状，包括相互穿透的表面
#### 缺点
- 内存消耗大（深度缓冲区通常与颜色缓冲区等大）
- 过度绘制（多个多边形在同一像素计算，但只有最近的有效）
- 深度精度问题，尤其是远距离物体
- 无法直接处理透明物体

### 变种与改进
- **W-Buffer**：使用倒数深度，改善深度精度分布
- **分层Z-Buffer**：使用多分辨率深度图，提前剔除不可见区域
- **Early-Z测试**：在像素着色前进行深度测试，减少不必要的着色计算

## 扫描线渲染

### 概述
扫描线渲染是基于逐行扫描原理的图形渲染技术，其核心通过按行处理像素实现图像绘制。该技术因不支持全局照明系统，无法精确模拟光线多次反射效果，导致阴影计算存在局限性，这一特征在3ds Max软件的默认渲染引擎中得到典型体现 。

与传统迭代渲染算法相比，扫描线渲染在计算效率方面具有优势，但在处理复杂光照场景时易出现失真问题。3ds Max软件的默认扫描线渲染引擎因不支持全局照明（Global Illumination），无法准确计算光线反射效果，导致渲染质量受限。数字城市建模领域通过烘焙贴图等技术弥补其缺陷，这种优化方案在工程实践中得到应用

#### 核心概念
- 扫描线：屏幕上的水平线，算法逐行从上到下处理
- 边：多边形边界线段，连接两个顶点
- 扫描线连贯性：相邻扫描线上的像素信息变化平缓，可增量计算

### 实现
#### 算法实现
```pseudocode
初始化边表ET，按y_max分组

for 每条扫描线 y = y_min to y_max:
    1. 将ET中y_max = y的边加入AEL
    2. 对AEL按x交点排序
    3. 确定扫描线区间：在AEL中成对取边，形成[x_left, x_right]区间
    4. 确定每个区间内的可见多边形：
        - 计算每个多边形在扫描线上的深度
        - 选择深度最小的多边形（最近的多边形）
    5. 填充区间：使用可见多边形的颜色填充像素
    6. 更新AEL：所有边的x += 1/m
    7. 移除AEL中y_max = y的边
```
#### 数据结构
##### 边表（ET - Edge Table）
存储所有非水平边，按边的最大y坐标（上端点）分组：
```plaintext
边结构包含：
- y_max：边的上端点y坐标
- x_min：边在当前扫描线的最低x坐标（初始为下端点的x）
- 1/m：边的斜率倒数（dx/dy）
- 指向多边形的指针
```

##### 活动边表（AEL - Active Edge List）
存储与当前扫描线相交的所有边，按x交点排序：
- 每处理一条扫描线，更新AEL中所有边的x坐标：x = x + 1/m
- 当边达到y_max时，从AEL中移除

#### 深度计算优化
- 增量深度计算：利用平面方程 z = Ax + By + C，可增量更新：
  ```
  z_scanline_start = A*x_start + B*y + C
  z_next_pixel = z_current + A  (当B=0时)
    ```
- 边相关性：相邻扫描线上同一多边形的深度变化连续

### 特点与优缺点
#### 优点
- 内存效率高（无需全屏深度缓冲区）
- 适合早期内存受限的系统
- 可处理大规模多边形场景
- 易于实现反走样（在扫描线级别）

#### 缺点
- 算法复杂度高，实现复杂
- 难以处理相互穿透的多边形
- 对动态场景更新效率低
- 现代硬件支持差

## 隐藏线渲染

### 概述
消隐技术是计算机图形学中解决三维形体二维投影二义性的核心技术，通过消除被遮挡的不可见线或面（即隐藏线/面），实现真实感图形渲染。该技术在给定三维对象集合及投影方式条件下，执行线、面或体的可见性判定，核心目标包含避免视觉歧义与提升图形真实性两类维度 。

根据算法实现方式可分为图像空间消隐与景物空间消隐两大类别，前者通过扫描线算法、深度缓冲算法等像素级处理实现，后者采用画家算法等几何运算方式。混合型算法如层次遮挡图算法，结合了两类空间的计算特性

#### 核心概念
- 线可见性判定：判断线段是被完全可见、部分可见还是完全隐藏
- 轮廓线识别：识别物体的外轮廓和内部特征线
- 交线处理：正确处理表面的交线可见性

### 实现
#### 实现方法
#####  基于表面的隐藏线消除
- 将线框模型转换为表面模型
- 使用Z-Buffer或扫描线算法判断表面可见性
- 仅绘制可见表面边界上的线条

##### 优先度算法（Painter's Algorithm变种）
- 按深度排序所有表面
- 从后往前处理表面
- 标记被遮挡的线段部分

##### 浮动水平线算法
- 用于参数曲面和函数图形的隐藏线消除
- 维护上水平线和下水平线
- 确定函数图形的可见部分

#### 算法流程（基于表面的方法）
```pseudocode
1. 表面可见性计算：
    使用Z-Buffer或扫描线算法确定每个像素的可见表面
    
2. 边可见性判断：
    对于每条边（线段）：
        a. 采样边上的多个点
        b. 检查每个采样点的可见性：
            - 计算采样点的深度
            - 与对应像素的深度缓冲区比较
        c. 根据采样结果确定边的可见状态：
            - 全可见：所有采样点可见
            - 全隐藏：所有采样点不可见
            - 部分可见：部分采样点可见
    
3. 可见边绘制：
    绘制全可见边
    对部分可见边进行裁剪，仅绘制可见部分
```
算法要点：
- 轮廓线增强：加粗或高亮显示外轮廓线
- 隐藏线样式：用虚线或浅色表示隐藏线
- 交线计算：精确计算表面交线及其可见性
- 深度提示：根据深度调整线条亮度或粗细

### 优缺点
#### 优点
- 保持线框模型的简洁性
- 增强三维理解，避免视觉歧义
- 适合工程和技术绘图
- 数据量小，适合早期显示设备

#### 缺点
- 计算复杂，需要表面信息
- 处理曲线和曲面困难
- 实时性能差
- 无法表示表面材质和光照效果

## 光线追踪渲染

### 概述
光线追踪是一种通过模拟光线在三维场景中的传播路径来生成逼真图像的计算机图形学技术，其核心原理包括光线发射、交点检测、递归追踪及光照计算，能够精确呈现反射、折射和全局光照效果。

该技术早期因计算复杂主要用于电影和广告的离线渲染，2018年英伟达通过AI优化关键算法实现帧率提升，Steam Machine等硬件开始支持实时光线追踪。随着专用硬件加速和混合绘制技术的发展，光线追踪已应用于游戏、汽车设计（如虚幻引擎的反射验证）和移动通信领域（电磁波传播模拟）
#### 核心原理
- 逆向光线追踪：从相机出发向场景发射光线，而非从光源出发
- 递归追踪：跟踪光线的反射、折射等多次反弹
- 蒙特卡洛方法：使用随机采样估计全局光照

### 实现
#### 算法实现
```pseudocode
function traceRay(ray, depth):
    if depth > MAX_DEPTH:
        return BACKGROUND_COLOR
    
    // 1. 寻找最近的交点
    hit_record = findClosestIntersection(ray)
    
    if no intersection:
        return BACKGROUND_COLOR
    
    // 2. 计算局部光照（直接光照）
    color = computeLocalIllumination(hit_record)
    
    // 3. 递归追踪反射光线
    if material is reflective:
        reflection_ray = computeReflectionRay(hit_record)
        color += traceRay(reflection_ray, depth+1) * reflectivity
    
    // 4. 递归追踪折射光线
    if material is transparent:
        refraction_ray = computeRefractionRay(hit_record)
        color += traceRay(refraction_ray, depth+1) * transparency
    
    // 5. 阴影测试
    for each light source:
        shadow_ray = ray from hit_point to light
        if shadow_ray hits an object:
            color *= shadow_factor
    
    return color
```

### 关键技术组件

#### 光线表示
```
Ray: origin + t * direction
t ∈ [0, ∞) 或 [t_min, t_max]
```

#### 光线-物体求交
- 球体：二次方程求解
- 平面：线性方程求解
- 三角形：Möller-Trumbore算法
- 包围盒：Slab方法
- 加速结构：BVH、KD-Tree、BSP Tree

#### 材质模型
- 漫反射：Lambertian模型
- 镜面反射：Phong/Blinn-Phong模型
- 折射：Snell定律，Fresnel方程
- 各向异性：微表面模型

#### 光照计算
- 直接光照：点光源、方向光、面光源
- 间接光照：路径追踪、光子映射
- 环境光：环境光遮蔽、IBL

### 加速技术
| 技术      | 原理           | 优点           |
| ------- | ------------ | ------------ |
| 包围体层次   | 将物体分组到层次包围盒中 | 自适应细分，适合复杂场景 |
| KD-Tree | 递归空间二分       | 高效，适合静态场景    |
| BVH     | 基于对象的层次包围盒   | 动态场景支持好      |
| 空间划分    | 均匀网格划分       | 简单，适合均匀分布物体  |
| 光束追踪    | 同时追踪光束而非单光线  | 减少冗余计算       |

### 现代扩展
- 路径追踪：无偏的蒙特卡洛全局光照
- 光子映射：双向光线追踪
- 辐射度算法：基于热辐射的全局光照
- 实时光线追踪：硬件加速（RTX）、降噪技术

### 特点与优缺点
#### 优点
- 照片级真实感图像质量
- 自然处理阴影、反射、折射
- 精确的全局光照效果
- 理论上可模拟所有光学现象

#### 缺点
- 计算量极大，渲染时间长
- 内存消耗大（加速结构）
- 实现复杂，调试困难
- 噪声问题（蒙特卡洛方法）